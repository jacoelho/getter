package main

import (
	"fmt"
	"go/types"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

type visitor struct {
	file       *jen.File
	imports    map[string]*packages.Package
	structName string
	structType *types.Struct
}

// New creates a new visitor
func New(object types.Object, imports map[string]*packages.Package) (*visitor, error) {
	if _, ok := object.(*types.TypeName); !ok {
		return nil, fmt.Errorf("type %#v is not a named type", object)
	}

	structType, ok := object.Type().Underlying().(*types.Struct)
	if !ok {
		return nil, fmt.Errorf("type %#v is not a struct", object)
	}

	return &visitor{
		file:       jen.NewFile(object.Pkg().Name()),
		structName: object.Name(),
		structType: structType,
		imports:    imports,
	}, nil
}

// Generates getters based on a struct
func (v *visitor) Generate() (*jen.File, error) {
	v.file.PackageComment(`Code generated by "getter", DO NOT EDIT.`)

	for i := 0; i < v.structType.NumFields(); i++ {
		field := v.structType.Field(i)

		if !field.Exported() || field.Embedded() {
			continue
		}

		v.file.Func().
			Params(
				jen.Id("v").Op("*").Id(v.structName)).
			Id("Get"+field.Name()).
			Params().Params(jen.Id("r").Do(func(statement *jen.Statement) {
			v.getTypeContent(statement, field.Type())
		}),
		).
			Block(
				jen.If(jen.Id("v").Op("==").Nil()).
					Block(jen.Return()),
				jen.Id("r").Op("=").Id("v").Dot(field.Name()),
				jen.Return(),
			)
	}

	return v.file, nil
}

func (v *visitor) getTypeContent(statement *jen.Statement, t types.Type) {
	switch tt := t.(type) {
	case *types.Chan:
		v.getChanType(statement, tt)
	case *types.Signature:
		v.getSignatureType(statement, tt)
	case *types.Array:
		v.getArrayType(statement, tt)
	case *types.Map:
		v.getMapType(statement, tt)
	case *types.Named:
		v.getNamedType(statement, tt)
	case *types.Pointer:
		v.getPointerType(statement, tt)
	case *types.Slice:
		v.getSliceType(statement, tt)
	case *types.Struct:
		v.getStructType(statement, tt)
	default:
		statement.Id(t.String())
	}
}

func (v *visitor) getArrayType(statement *jen.Statement, t *types.Array) {
	statement.Op("[]")
	v.getTypeContent(statement, t.Elem())
}

func (v *visitor) getMapType(statement *jen.Statement, t *types.Map) {
	statement.Op("map[")
	v.getTypeContent(statement, t.Key())
	statement.Op("]")
	v.getTypeContent(statement, t.Elem())
}

func (v *visitor) getPointerType(statement *jen.Statement, t *types.Pointer) {
	statement.Op("*")
	v.getTypeContent(statement, t.Elem())
}

func (v *visitor) getSignatureType(statement *jen.Statement, t *types.Signature) {
	statement.Op("func")

	var params jen.Statement
	for i := 0; i < t.Params().Len(); i++ {
		j := &jen.Statement{}
		v.getTypeContent(j, t.Params().At(i).Type())
		params = append(params, j)
	}
	statement.Params(params...)

	var results jen.Statement
	for i := 0; i < t.Results().Len(); i++ {
		j := &jen.Statement{}
		v.getTypeContent(j, t.Results().At(i).Type())
		results = append(results, j)
	}
	statement.Params(results...)
}

func (v *visitor) getNamedType(statement *jen.Statement, t *types.Named) {
	p := t.Obj()

	_, ok := v.imports[p.Pkg().Path()]
	if ok {
		statement.Qual(p.Pkg().Path(), p.Name())
	} else {
		statement.Id(p.Name())
	}
}

func (v *visitor) getSliceType(statement *jen.Statement, t *types.Slice) {
	statement.Op("[]")
	v.getTypeContent(statement, t.Elem())
}

func (v *visitor) getChanType(statement *jen.Statement, t *types.Chan) {
	switch t.Dir() {
	case types.SendOnly:
		statement.Op("chan <-")
	case types.RecvOnly:
		statement.Op("<- chan")
	default:
		statement.Op("chan")
	}

	v.getTypeContent(statement, t.Elem())
}

func (v *visitor) getStructType(statement *jen.Statement, t *types.Struct) {
	statement.Op("struct{ ")

	for i := 0; i < t.NumFields(); i++ {
		v.getTypeContent(statement, t.Field(i).Type())
	}

	statement.Op("}")
}
