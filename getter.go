package main

import (
	"flag"
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

var (
	typeNames = flag.String("type", "", "comma-separated list of type names; must be set")
)

const (
	usage = `Usage of getter:
ringer [flags] -type T [directory]
stringer [flags] -type T files...
Options:
`
)

var reTyp = regexp.MustCompile("[\\w\\.\\-_/]+")

func main() {
	flag.Usage = func() {
		fmt.Fprint(flag.CommandLine.Output(), usage, os.Args[0])
		flag.PrintDefaults()
	}

	flag.Parse()

	wantTypes := strings.Split(*typeNames, ",")

	args := flag.Args()
	if len(args) == 0 {
		args = []string{"."}
	}

	pkgs, err := loadPackage(args...)
	if err != nil {
		fmt.Fprint(os.Stderr, err.Error())
		os.Exit(1)
	}

	imports := make(map[string]*packages.Package)
	for k, v := range pkgs.Imports {
		imports[k] = v
	}

	for _, t := range wantTypes {
		obj := pkgs.Types.Scope().Lookup(t)
		if obj == nil {
			continue
		}

		if _, ok := obj.(*types.TypeName); !ok {
			fmt.Fprintf(os.Stderr, "%v is not a named type", obj)
			os.Exit(1)
		}

		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			fmt.Fprintf(os.Stderr, "type %v is not a struct", obj)
			os.Exit(1)
		}

		f := jen.NewFile(obj.Pkg().Name())
		f.PackageComment(`Code generated by "getter", DO NOT EDIT.`)

		generate(f, t, structType, imports)

		goFile := os.Getenv("GOFILE")
		ext := filepath.Ext(goFile)
		baseFilename := goFile[0 : len(goFile)-len(ext)]
		targetFilename := baseFilename + "_" + strings.ToLower(t) + "_gen.go"

		if err := f.Save(targetFilename); err != nil {
			fmt.Fprint(os.Stderr, err.Error())
			os.Exit(1)
		}
	}
}

func generate(f *jen.File, sourceTypeName string, structType *types.Struct, imports map[string]*packages.Package) {
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		value := field.Type()

		switch value.(type) {
		case *types.Struct:
			continue
		}

		if !field.Exported() || field.Embedded() {
			continue
		}

		f.Func().
			Params(
				jen.Id("v").Op("*").Id(sourceTypeName)).
			Id("Get"+field.Name()).
			Params().Params(jen.Id("r").Do(func(statement *jen.Statement) {
			//typeString(statement, imports, field.Type())
			getTypeContent(statement, imports, field.Type())
			// switch v := field.Type().(type) {
			// case *types.Pointer:
			// 	switch p := v.Elem().(type) {
			// 	case *types.Named:
			// 		typeName := p.Obj()

			// 		if typeName.Pkg().Path() == goPackage {
			// 			statement.Op("*").Id(typeName.Name())
			// 		} else {
			// 			statement.Op("*").Qual(typeName.Pkg().Path(), typeName.Name())
			// 		}

			// 	default:
			// 		statement.Id(v.String())
			// 	}

			// case *types.Named:
			// 	typeName := v.Obj()

			// 	if typeName.Pkg().Path() == goPackage {
			// 		statement.Id(typeName.Name())
			// 	} else {
			// 		statement.Qual(typeName.Pkg().Path(), typeName.Name())
			// 	}

			// default:
			// 	statement.Id(v.String())
			// }
		})).
			Block(
				jen.If(jen.Id("v").Op("==").Nil()).
					Block(jen.Return()),
				jen.Id("r").Op("=").Id("v").Dot(field.Name()),
				jen.Return(),
			)
	}
}

func typeString(statement *jen.Statement, imports map[string]*packages.Package, t types.Type) {
	switch v := t.(type) {
	case *types.Pointer:
		switch v.Elem().(type) {
		case *types.Named:
			statement.Op("*")
			typeString(statement, imports, v.Elem())

		default:
			statement.Id(v.String())
		}

	case *types.Named:
		typeName := v.Obj()

		_, ok := imports[typeName.Pkg().Path()]
		if ok {
			statement.Qual(typeName.Pkg().Path(), typeName.Name())
		} else {
			statement.Id(typeName.Name())
		}
	case *types.Map:

	default:
		t := v.String()
		fmt.Printf("%#v\n", filepath.Base(t))
		// pos := strings.LastIndex(t, ".")
		// if pos > 0 {
		// 	pkg := t[:pos]
		// 	if _, ok := imports[pkg]; ok {
		// 		t = filepath.Base(t)
		// 	} else {
		// 		t = t[pos+1:]
		// 	}
		// }

		//t = fixPkgString(imports, t)
		statement.Id(t)
	}
}

func loadPackage(paths ...string) (*packages.Package, error) {
	cfg := &packages.Config{
		Mode:  packages.NeedTypes | packages.NeedImports | packages.NeedFiles | packages.NeedName,
		Tests: false,
		Env:   os.Environ(),
	}
	pkgs, err := packages.Load(cfg, paths...)
	if err != nil {
		return nil, fmt.Errorf("loading packages for inspection: %w", err)
	}

	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0], nil
}

func getTypeContent(statement *jen.Statement, imports map[string]*packages.Package, t types.Type) {
	switch tt := t.(type) {
	case *types.Chan:
		getChanType(statement, imports, tt)
	// case *types.Interface:
	// 	statement.Id("Record<string, any>")
	// case *types.Basic:
	// 	statement.Id(t.String())
	case *types.Array:
		getArrayType(statement, imports, tt)
	case *types.Map:
		getMapType(statement, imports, tt)
	case *types.Named:
		getNamedType(statement, imports, tt)
	case *types.Pointer:
		getPointerType(statement, imports, tt)
	case *types.Slice:
		getSliceType(statement, imports, tt)
	case *types.Struct:
		getStructType(statement, imports, tt)
	default:
		statement.Id(t.String())
	}
}

func getArrayType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Array) {
	statement.Op("[]")
	getTypeContent(statement, imports, t.Elem())
}

func getMapType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Map) {
	statement.Op("map[")
	getTypeContent(statement, imports, t.Key())
	statement.Op("]")
	getTypeContent(statement, imports, t.Elem())
}

func getPointerType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Pointer) {
	statement.Op("*")
	getTypeContent(statement, imports, t.Elem())
}

func getNamedType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Named) {
	p := t.Obj()

	_, ok := imports[p.Pkg().Path()]
	if ok {
		statement.Qual(p.Pkg().Path(), p.Name())
	} else {
		statement.Id(p.Name())
	}
}

func getSliceType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Slice) {
	statement.Op("[]")
	getTypeContent(statement, imports, t.Elem())
}

func getChanType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Chan) {
	statement.Op("chan")
	getTypeContent(statement, imports, t.Elem())
}

func getStructType(statement *jen.Statement, imports map[string]*packages.Package, t *types.Struct) {
	statement.Op("struct{ ")
	for i := 0; i < t.NumFields(); i++ {
		getTypeContent(statement, imports, t.Field(i).Type())
	}
	statement.Op("}")
}
